LeRobot Rate Monotonic Data Acquisition
=======================================

500Hz synchronized IMU + Servo encoder capture for LeRobot datasets.

Hardware
--------
- Teensy 4.1
- ISM330DHCX IMU (SPI1 @ 4MHz)
- Feetech STS3215 servo (Serial3 @ 1Mbaud)
- Serial4 @ 2Mbaud for data output

Projects
--------
Lerobot_RM_Phase1/    IMU-only @ 500Hz (validated)
Lerobot_RM_Phase2/    IMU + Servo with Seqlock (validated)
Lerobot_RM_Phase3/    Full multirate realtime control and data acquisition stack
adafruit_ism330dhcx_test/    IMU test sketch
feetech_servo_timing_test/   Servo timing test

Phase 2 Features
----------------
- Writer-Preferred Seqlock (lock-free ISR->main sync)
- SPI_MODE3 + delayNanoseconds(125) for Teensy 4.x
- BDU, I2C_disable, DEVICE_CONF per ISM330DHCX datasheet
- Coherency validation (XOR checksum + torn read detection)
- Non-blocking debug ring buffer (rate-limited drain)

Phase 3 Features
----------------
- Full interrupt-driven, multi-rate real-time control and data-acquisition stack
- Rate-Monotonic scheduling via hardware timer/NVIC priorities
- Synchronize IMU and servo encoder data with sub-300 µs temporal skew 
- Writer-Preferred Seqlock (lock-free ISR->main sync) 
- Robust non-blocking logging ring buffer (rate-limited drain) 


Usage
-----
1. Flash firmware via Arduino IDE
2. Run Python parser:
   python3 Lerobot_RM_Phase2/parse_phase2_csv.py /dev/ttyACM0 2000000 -o capture.csv -v

Wiring (SPI1)
-------------
CS   -> Pin 0  (10k pull-down to GND required)
SCK  -> Pin 27
MOSI -> Pin 26
MISO -> Pin 1
VCC  -> 3.3V
GND  -> GND


12/8/25 Update 
---------------

Section 1 -> Progress towards goal 
- Phase 3 is the complete core implementation of the control and data acquisitions stack 
- Time from IMU reading -> Encoder reading is under 300 µs
- schedules servo encoder read requests [500Hz] and servo position write request [100Hz]
- Use Deferred interrupt pattern at 500Hz, to queue these read and write request, all arbitrated by a FSM
- Robust logging and documentation times, for all events. Line 82 where the sensor data struct lives defines this.  
- ***one cycle pipeline***, IMU data from frame{k} corresponds to Encoder data frame{k-1} this 1 phase offset is handled in parse_phase3_csv.py
- I have already architected the serial stream of generateSineSweep, and will implement tonight.
- Scheduled talk with friend doing imitation learning at MIT to come up with good benchmark tests 
- **After this: last step is pure Covalent side orchestration and data processing** 

Section 2 -> architecture
- 3 virtualized CPUs with different priorities 
   - CPU A -> Frame_ISR[500hz] line 690
      - highest priority every 2000 µs
      - snapshots the imu (33 µs)
      - checks the state of the servo 
      - if no message is sent it sets flag to queue a servo read/write request
      - **no I/O just flag setter**
      -  returns in under 50 us
   - CPU B -> Triggered by serial rx (servo return)
      - second highest priority 
      - pushes bytes from the internal Serial 3 buffer to be processed in the main loop 
   - CPU C -> the meat and potatoes 
      - Lowest Priority 
      - these are the processes that run every iteration, and execute all i/o functionality 
      - where all logging, servo read and write etc is done
      - line 990  

Section 3 -> Steps to Replicate 
1. flash Lerobot_RM_Phase3.ino to the Teensy 
2. once flashed ask linux if there is any information coming over serial port  
   stty -F /dev/ttyUSB0 2000000 raw -echo
   Teensy should be sending **READY** every second
3. Run python3 /home/alex/Arduino/Reforge_Lerobot/Lerobot_RM_Phase3/parse_phase3_csv.py /dev/ttyUSB0 2000000 -o test.csv -v
4. This initiates the handshake between the Teensy and Python and starts the data collection process 
5. Press Ctrl + C to stop the test, and produce results 


12/17/25 Update 
---------------
Section 1 -> Progress towards goal 
- phase 5 is the new most current verison: full deffered interrupt pattern + State machine fucntionality for setting different data runs, moving mode 
- Features:
   - Move mode - blocking slow moving for going to different configurations
   - Data mode - executes system ID sine sweep and data collection at 500hz
Implemented the Teensy Hardware API, for interfacing with the teensy. Allows for communication abritiation on 2 serial ports(need to share the covalent_base-Lerobot_SO10-)
- implement all fucntions in the Template Robot 
- Final issue is IMU integration
   - 1m long wires required: interferes with start up sequence, so ordered capicitors, and stablize the initial energy surge. should be here this weekend


Section 2 -> architecture

Teensy Serial Interface 
┌─────────────────────────────────────────────────────────────────────┐
│                     TeensySerialInterface                           │
│                     (Facade / Public API)                           │
│  • Radians-based joint control                                      │
│  • Trajectory session management                                    │
│                                                                     │  
└──────────────┬──────────────────────────────────┬───────────────────┘
               │                                  │
               ▼                                  ▼
┌──────────────────────────────┐    ┌─────────────────────────────────┐
│         TeensyUSB            │    │     Serial4CaptureThread        │
│     (Actor Pattern)          │    │     (Dedicated I/O Thread)      │
│                              │    │                                 │
│  • Queue-based command       │    │  • 500Hz binary frame capture   │
│    serialization             │    │  • FTDI @ 2Mbaud                │
│  • Single worker thread      │    │  • Raw .bin file output         │
│  • Future-based responses    │    │  • Frame validation             │
└──────────────┬───────────────┘    └─────────────────────────────────┘
               │
               ▼
┌──────────────────────────────┐
│   StreamingExclusiveGuard    │
│   (Concurrency Policy)       │
│                              │
│  • Prevents concurrent USB   │
│  • Whitelist for safe cmds   │
│  • Thread ownership tracking │
└──────────────────────────────┘

Protocol
--------
| Command                  | Response                          | Purpose            |
|--------------------------|-----------------------------------|--------------------|
| PING                     | PONG,<mode>                       | Handshake, get mode|
| MODE,MOVE                | MODE,MOVE,OK                      | Enter motion mode  |
| MODE,DATA                | MODE,DATA,OK                      | Enter data mode    |
| SYNCW,n,id,pos,spd,...   | OK                                | Multi-joint write  |
| READJ                    | POS,p1,p2,p3,p4,p5,p6             | Read all joints    |
| G,pos,speed              | (none)                            | Trajectory goal    |
| RUN,START                | RUN,START,OK + EVT,LOGGING_ON     | Start ISR          |
| RUN,STOP                 | RUN,STOP,OK + EVT,LOGGING_OFF     | Stop ISR           |

interfaces with Lerobot_RM_Phase5/Lerobot_RM_Phase5.ino
-------------------------------------------------------

                    ┌─────────────┐
                    │  MODE_WAIT  │  (Boot state, LED @ 1Hz)
                    └──────┬──────┘
                           │ MODE,MOVE or MODE,DATA
              ┌────────────┴────────────┐
              ▼                         ▼
     ┌─────────────────┐      ┌─────────────────┐
     │   MODE_MOVE     │      │ MODE_DATA_IDLE  │
     │   (LED @ 4Hz)   │      │   (LED @ 2Hz)   │
     │                 │      │                 │
     │ • SYNCW command │      │ • No ISR yet    │
     │ • READJ command │      │ • Waiting for   │
     │ • Blocking I/O  │      │   RUN,START     │
     └────────┬────────┘      └────────┬────────┘
              │                        │ RUN,START
              │                        ▼
              │               ┌─────────────────┐
              │               │ MODE_DATA_RUN   │
              │               │  (LED @ 10Hz)   │
              │               │                 │
              │               │ • 500Hz ISR     │
              │               │ • G commands    │
              │               │ • Serial4 stream│
              │               └────────┬────────┘
              │                        │ RUN,STOP
              │                        ▼
              │               ┌─────────────────┐
              │               │ MODE_DATA_IDLE  │
              └───────────────┴─────────────────┘
                     MODE,MOVE / MODE,DATA

Section 3  -> Steps to Reproduce 
--------------------------------
1. Teensy_serial_interface 
select which port it hooked up to the the FTDI and which is connected to usb serial 

set in the module constructor 

robot = TeensySerialInterface(
    usb_port="/dev/ttyACM0",   # Teensy USB (commands)
    ftdi_port="/dev/ttyUSB0"   # FTDI adapter (500Hz binary data)
)

2. Upload firmware: Lerobot_RM_Phase5.ino to teensy firmware 

3. start the virtual env 
cd /home/alex/Reforge/covalent-base-Lerobot_SO101/src
python3 -m robots.teensy_serial_interface.test_interface

| Command                       | Description                              |
|-------------------------------|------------------------------------------|
| r                             | Read joint positions + FK pose           |
| m p1,p2,p3,p4,p5,p6 [speed]   | Move to joint positions (radians)        |
| hm [speed]                    | Move to home position [0, π/2, -π/2, 0, 0, 0] |
| ik x,y,z                      | Test inverse kinematics (no move)        |
| mp x,y,z [speed]              | Move to Cartesian position via IK        |
| L N                           | Sine sweep on axis N (1-5)               |
| mode move                     | Ensure MOVE mode                         |
| h                             | Help                                     |
| q                             | Quit                                     |


12/22/25 Update 
---------------
- Section 1 -> Progress towards goal 
- Implement, RosBridgeManager to offload IK/FK and Trajectory planning to ROS MoveIt
- Integrated into test_interface.py for testing 
- Verified IK/FK solutions from MoveIt to match with covalent robot kinematics model 
- Ran the moveit setup assistant to generate a basic planning config for Lerobot_SO101
- mother-fin SPI with long wires did not work
-  so moved teensy to the end effector mount, and all systems are working, I tried all weekend, but I think moving the teensy to the end effector was the right move.
- Now I need a little more time to Iron out the IK/FK sequence for what is need the in the TemplateRobot interface but super close.
- Section 2 -> architecture

ROS Bridge Module
┌─────────────────────────────────────────────────────────────────────┐
│                     ros_bridge Package                              │
│                  (Non-ROS Python → MoveIt Services)                 │
│                                                                     │
│  • WebSocket-based ROS communication (no ROS install needed)        │
│  • Persistent connection management                                 │
│  • Position-only IK for 5-DOF arm                                   │
│  • Trajectory planning & preview                                    │
└──────────────┬──────────────────────────────────┬───────────────────┘
               │                                  │
               ▼                                  ▼
┌──────────────────────────────┐    ┌─────────────────────────────────┐
│    RosBridgeManager          │    │      MoveIt Services            │
│  (Connection Lifecycle)      │    │   (via rosbridge WebSocket)     │
│                              │    │                                 │
│  • Persistent roslibpy.Ros   │    │  • /compute_ik                  │
│    client (port 9090)        │    │    - TRAC-IK solver             │
│  • Service proxy creation:   │    │    - position_only_ik: true     │
│    - ik_service              │    │    - 0.5s timeout               │
│    - fk_service              │    │  • /compute_fk                  │
│    - planning_service        │    │    - Forward kinematics         │
│  • Context manager support   │    │  • /plan_kinematic_path         │
│  • Single connection for     │    │    - Motion planning            │
│    entire session            │    │    - Collision avoidance        │
└──────────────┬───────────────┘    └─────────────────────────────────┘
               │
       ┌───────┴────────┬──────────────────┐
       ▼                ▼                   ▼
┌──────────────┐   ┌────────────┐   ┌──────────────────┐
│ moveit_ik.py │   │ros_preview │   │ros_preview_moveit│
│  (IK/FK)     │   │   (legacy) │   │ (Planning/RViz)  │
│              │   │            │   │                  │
│ • compute_ik │   │ • joint    │   │ • plan_and       │
│   _moveit()  │   │   _states  │   │   _preview       │
│ • compute_fk │   │   publish  │   │   _trajectory()  │
│   _moveit()  │   │            │   │ • Publishes to   │
│ • Blocking   │   │            │   │   /move_group/   │
│   service    │   │            │   │   display_planned│
│   calls      │   │            │   │   _path          │
│ • Dual-mode: │   │            │   │ • User approval  │
│   persistent │   │            │   │   (y/n prompt)   │
│   or one-shot│   │            │   │ • Dual-mode      │
└──────────────┘   └────────────┘   └──────────────────┘
```

this allows to call moveit for the IK/FK solution it is then compared with the FK on the model loaded in the covalent base and then executed
- the trajectory is shown on RVIZ and you are prompted wether to execute or not.

Section 3  -> Steps to Reproduce
--------------------------------

this is where the setup get a little hard 
I am not super experience used Github for colaboration, so I think the best move would be to add you as a colaborator, to the covalent-base-Lerobot_SO101 repo, so you can access all the files.
I have 2 custom Ros Packages that I am made 
1. Moveit setup assisant contains the urdf, kinematics, motion planning etc
2. rosbridge_server to allow for web socket communication

run:
roslaunch rosbridge_server rosbridge_websocket.launch
- roslaunch moveit_setup_assistant moveit_setup_assistant.launch
roslaunch Reforge_LeRobot_moveit_config lerobot_ik.launch
- starts the movegroup ros node, and everything else moveit for kinematics 

python3 -m robots.teensy_serial_interface.test_interface
- runs the test interface that connects to the teensy and rosbridge to do IK/FK and trajectory planning

for the Sine_sweep data collection current implemented with the commands specified last week, but the runs are stored in 
src/calibration/runs